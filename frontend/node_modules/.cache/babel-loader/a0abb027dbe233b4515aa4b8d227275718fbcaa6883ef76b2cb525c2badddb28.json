{"ast":null,"code":"'use strict';\n\nconst prompts = require('./prompts');\nconst passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];\nconst noop = () => {};\n\n/**\n * Prompt for a series of questions\n * @param {Array|Object} questions Single question object or Array of question objects\n * @param {Function} [onSubmit] Callback function called on prompt submit\n * @param {Function} [onCancel] Callback function called on cancel/abort\n * @returns {Object} Object with values from user input\n */\nasync function prompt(questions = [], {\n  onSubmit = noop,\n  onCancel = noop\n} = {}) {\n  const answers = {};\n  const override = prompt._override || {};\n  questions = [].concat(questions);\n  let answer, question, quit, name, type, lastPrompt;\n  const getFormattedAnswer = async (question, answer, skipValidation = false) => {\n    if (!skipValidation && question.validate && question.validate(answer) !== true) {\n      return;\n    }\n    return question.format ? await question.format(answer, answers) : answer;\n  };\n  for (question of questions) {\n    ({\n      name,\n      type\n    } = question);\n\n    // evaluate type first and skip if type is a falsy value\n    if (typeof type === 'function') {\n      type = await type(answer, {\n        ...answers\n      }, question);\n      question['type'] = type;\n    }\n    if (!type) continue;\n\n    // if property is a function, invoke it unless it's a special function\n    for (let key in question) {\n      if (passOn.includes(key)) continue;\n      let value = question[key];\n      question[key] = typeof value === 'function' ? await value(answer, {\n        ...answers\n      }, lastPrompt) : value;\n    }\n    lastPrompt = question;\n    if (typeof question.message !== 'string') {\n      throw new Error('prompt message is required');\n    }\n\n    // update vars in case they changed\n    ({\n      name,\n      type\n    } = question);\n    if (prompts[type] === void 0) {\n      throw new Error(`prompt type (${type}) is not defined`);\n    }\n    if (override[question.name] !== undefined) {\n      answer = await getFormattedAnswer(question, override[question.name]);\n      if (answer !== undefined) {\n        answers[name] = answer;\n        continue;\n      }\n    }\n    try {\n      // Get the injected answer if there is one or prompt the user\n      answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);\n      answers[name] = answer = await getFormattedAnswer(question, answer, true);\n      quit = await onSubmit(question, answer, answers);\n    } catch (err) {\n      quit = !(await onCancel(question, answers));\n    }\n    if (quit) return answers;\n  }\n  return answers;\n}\nfunction getInjectedAnswer(injected, deafultValue) {\n  const answer = injected.shift();\n  if (answer instanceof Error) {\n    throw answer;\n  }\n  return answer === undefined ? deafultValue : answer;\n}\nfunction inject(answers) {\n  prompt._injected = (prompt._injected || []).concat(answers);\n}\nfunction override(answers) {\n  prompt._override = Object.assign({}, answers);\n}\nmodule.exports = Object.assign(prompt, {\n  prompt,\n  prompts,\n  inject,\n  override\n});","map":{"version":3,"names":["prompts","require","passOn","noop","prompt","questions","onSubmit","onCancel","answers","override","_override","concat","answer","question","quit","name","type","lastPrompt","getFormattedAnswer","skipValidation","validate","format","key","includes","value","message","Error","undefined","_injected","getInjectedAnswer","initial","err","injected","deafultValue","shift","inject","Object","assign","module","exports"],"sources":["/Users/vaibhavh/Desktop/connectVerse/connect-verse-frontend/node_modules/prompts/lib/index.js"],"sourcesContent":["'use strict';\n\nconst prompts = require('./prompts');\n\nconst passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];\nconst noop = () => {};\n\n/**\n * Prompt for a series of questions\n * @param {Array|Object} questions Single question object or Array of question objects\n * @param {Function} [onSubmit] Callback function called on prompt submit\n * @param {Function} [onCancel] Callback function called on cancel/abort\n * @returns {Object} Object with values from user input\n */\nasync function prompt(questions=[], { onSubmit=noop, onCancel=noop }={}) {\n  const answers = {};\n  const override = prompt._override || {};\n  questions = [].concat(questions);\n  let answer, question, quit, name, type, lastPrompt;\n\n  const getFormattedAnswer = async (question, answer, skipValidation = false) => {\n    if (!skipValidation && question.validate && question.validate(answer) !== true) {\n      return;\n    }\n    return question.format ? await question.format(answer, answers) : answer\n  };\n\n  for (question of questions) {\n    ({ name, type } = question);\n\n    // evaluate type first and skip if type is a falsy value\n    if (typeof type === 'function') {\n      type = await type(answer, { ...answers }, question)\n      question['type'] = type\n    }\n    if (!type) continue;\n\n    // if property is a function, invoke it unless it's a special function\n    for (let key in question) {\n      if (passOn.includes(key)) continue;\n      let value = question[key];\n      question[key] = typeof value === 'function' ? await value(answer, { ...answers }, lastPrompt) : value;\n    }\n\n    lastPrompt = question;\n\n    if (typeof question.message !== 'string') {\n      throw new Error('prompt message is required');\n    }\n\n    // update vars in case they changed\n    ({ name, type } = question);\n\n    if (prompts[type] === void 0) {\n      throw new Error(`prompt type (${type}) is not defined`);\n    }\n\n    if (override[question.name] !== undefined) {\n      answer = await getFormattedAnswer(question, override[question.name]);\n      if (answer !== undefined) {\n        answers[name] = answer;\n        continue;\n      }\n    }\n\n    try {\n      // Get the injected answer if there is one or prompt the user\n      answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);\n      answers[name] = answer = await getFormattedAnswer(question, answer, true);\n      quit = await onSubmit(question, answer, answers);\n    } catch (err) {\n      quit = !(await onCancel(question, answers));\n    }\n\n    if (quit) return answers;\n  }\n\n  return answers;\n}\n\nfunction getInjectedAnswer(injected, deafultValue) {\n  const answer = injected.shift();\n    if (answer instanceof Error) {\n      throw answer;\n    }\n\n    return (answer === undefined) ? deafultValue : answer;\n}\n\nfunction inject(answers) {\n  prompt._injected = (prompt._injected || []).concat(answers);\n}\n\nfunction override(answers) {\n  prompt._override = Object.assign({}, answers);\n}\n\nmodule.exports = Object.assign(prompt, { prompt, prompts, inject, override });\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}